
set.seed(1234)

# Create test matrix
test = matrix(rnorm(200), 20, 10)
test[seq(1, 20, 2),1:5 ]  <- test[seq(1, 20, 2),1:5 ] + 2
test[seq(2, 20, 2),6:10] <- test[seq(2, 20, 2),6:10] + 1
test[seq(2, 20, 2),8:10] <- test[seq(2, 20, 2),8:10] + 3
test[,c(2,5,8)] <- test[,c(2,5,8)] + 20
colnames(test) = paste("Gene_", 1:10, sep = "")
rownames(test) = paste("ID_", 1:20, sep = "")
test<-exp(test)
View(test)



boxplot(test) # hÃ¤ufig beobachtet man linksgipflige Verteilung
test<-log(test) # transformation mittels log
boxplot(test)

library(pheatmap)
pheatmap(test,scale = "none", cluster_rows = F, cluster_cols = F)

# Normalization z-values

ztest <- apply(test,2,function(x) (x-mean(x))/sd(x))
# stest<-scale(test) # Alternative zur Berechnung des z-score
View(ztest)
boxplot(ztest)
pheatmap(ztest,scale = "none", cluster_rows = F, cluster_cols = F)

# Normalization z-values (Quantil)
install.packages("BiocManager")
BiocManager::install("preprocessCore")
library(preprocessCore)

qtest<-normalize.quantiles(test)
View(qtest)
pheatmap(qtest,scale = "none", cluster_rows = F, cluster_cols = F)
pheatmap(qtest,scale = "column", cluster_rows = F, cluster_cols = F)

 
# Cluster Analysis

plot(hclust(dist(ztest)))    # method = "euclidean"
plot(hclust(dist(t(ztest))))


# Heatmaps + Cluster Analysis

pheatmap(test,scale = "none", cluster_rows = T, cluster_cols = T)
pheatmap(ztest,scale = "none", cluster_rows = T, cluster_cols = T)
pheatmap(qtest,scale = "none", cluster_rows = T, cluster_cols = T)


# PCA: Principal Component

pca<-prcomp(test, center=T, scale=T);
pca<-prcomp(test)
summary(pca)
plot(pca)

biplot(pca)

plot(pca[[5]][,1:2])

library(ggfortify)
autoplot(pca,loadings = TRUE,loadings.label = TRUE)
                

# Cluster: Partitioning Around Medoids (a more robust version of K-means)

library(cluster)
autoplot(pam(test, 3), frame = TRUE, frame.type = 'norm')
autoplot(pam(test, 3), frame = TRUE, frame.type = 'norm',loadings = TRUE,loadings.label = TRUE)


# Cluster: Clustering Large Applications 
# (Compared to other partitioning methods such as pam, it can deal with much larger datasets)

autoplot(clara(test, 3))
autoplot(clara(test, 3), loadings = TRUE,loadings.label = TRUE)


# Cluster Profiles

(x<-pam(test, 3))
cluster<-x$clustering
data<-scale(x$data)

maxclust<-max(cluster)
#par(mfrow=c(maxclust,1))

par(mfrow=c(2,2))

for (i in 1:maxclust) {
          matplot(t(data[cluster==i,]), type="l", col='grey', xaxt = 'n',ylab="Concentration")
          axis(side=1,at=1:ncol(data),labels=colnames(data),las=2)
          lines(apply(t(data[cluster==i,]), 1, median), type="l", col='blue', lwd=1)
}


par(mfrow=c(1,1))

